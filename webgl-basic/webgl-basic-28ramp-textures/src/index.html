<!--
Ref: https://webglfundamentals.org/
-->
<div class="wrapper">
  <canvas id="c">Your browser does not seem to support HTML5 canvas.</canvas>
</div>
<script id="normal_vshader" type="x-shader/x-vertex">
  #version 100
  
  // 기본 정밀도 설정: check highp
// #ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
//  #else
//  precision mediump float;
//  #endif
  
  // 데이터 저장할 속성
  attribute vec4 a_position;
  attribute vec3 a_normal;
  
  // 데이터 저장할 유니폼(사용자정의)
  uniform mat4 u_projection; // 투영 행렬
  uniform mat4 u_view; // 뷰 행렬
  uniform mat4 u_world; // 월드 행렬
    
  // 베링을 사용해서 프레그먼트로 동일한 동명 배링으로 전달
  varying vec3 v_normal; // 전달받은 
    
  void main() {
    // 정점에 월드 행렬 적용
    vec4 worldView = u_view * u_world * a_position;
    
    gl_Position = u_projection * worldView;
    v_normal = a_normal;
  }
</script>
<script id="normal_fshader" type="x-shader/x-fragment">
  #version 100
  
  // 기본 정밀도 설정: check highp
  //#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
 // #else
  //precision mediump float;
 // #endif
  
  // 데이터 저장할 유니폼
  uniform vec3 u_reverseLightDir;
  uniform vec4 u_color;
  uniform sampler2D u_ramp;
  uniform vec2 u_rampSize;
  uniform float u_linearAdjust;
  // uniform bool u_useRampTexture;
  
  // 전달받는 베링
  varying vec3 v_normal; // 전달받은 
    
  void main() {
    vec3 normal = normalize(v_normal);
    float light = dot(normal, u_reverseLightDir);
    float u = light * 0.5 + 0.5;
    vec2 uv = vec2(u, 0.5);
    
    // 램프크기로 범위 조절
    // 
    // vec2 texelRange = uv * (u_rampSize - 1.0) + 0.5;
    vec2 texelRange = uv * (u_rampSize - u_linearAdjust);
    // 텍셀 절반 오프셋하고 텍스처 좌표 변환
    // vec2 rampUV = texelRange / u_rampSize;
    vec2 rampUV = (texelRange + 0.5 * u_linearAdjust) / u_rampSize;
    
    // vec4 rampColor = texture2D(u_ramp, uv);
    vec4 rampColor = texture2D(u_ramp, rampUV);
    // if (!u_useRampTexture) {
    //   rampColor = vec4(u, u, u, 1);
    // }
    gl_FragColor = u_color;
    // gl_FragColor.rgb *= light;
    gl_FragColor *= rampColor;
  }
</script>